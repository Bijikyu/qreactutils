import { QueryClient, QueryFunction } from "@tanstack/react-query"; //(import react-query types)
import axios, { AxiosResponse } from "axios"; //(use axios instead of fetch)
import { codexRequest } from "@shared/codexRequest"; //(mock network in Codex)

// This module centralizes API access logic for the front end. //(explain file purpose)
// apiRequest standardizes axios calls with JSON & credential defaults. //(explain wrapper goal)
// getQueryFn creates a react-query QueryFunction that knows how to deal with 401s. //(describe function role)
// Example usage:
//   const task = await apiRequest('/api/tasks', 'POST', { name: 't' }); //(call wrapper)
//   queryFn: getQueryFn({ on401: 'returnNull' }) //(use in React Query)

const axiosClient = axios.create({ withCredentials: true, headers: { "Content-Type": "application/json" } }); //(axios instance with cookies)

function formatAxiosError(err: unknown): Error { //(normalize axios error)
  console.log(`formatAxiosError is running with ${err}`);
  try {
    if (axios.isAxiosError(err)) { //(check for axios error)
      const status = err.response?.status ?? 500;
      const data = err.response?.data ?? err.message;
      const error = new Error(`${status}: ${typeof data === 'string' ? data : JSON.stringify(data)}`);
      console.log(`formatAxiosError is returning ${error}`);
      return error;
    }
    console.log(`formatAxiosError is returning ${err}`);
    return err as Error;
  } catch (error) {
    console.error('formatAxiosError error:', error);
    return err as Error;
  }
}

// apiRequest wraps axios so all calls share cookies & json handling. //(describe function purpose)
// Example: const user = await apiRequest('/api/user', 'GET'); //(usage example)
export async function apiRequest<T = any>(
  url: string,
  method: string = `POST`,
  data?: unknown,
): Promise<T> {
  console.log(`apiRequest is running with ${method} ${url}`); //(log start)
  try {
    const response = await codexRequest( //(handle Codex offline mode)
      () => axiosClient.request<T>({ url, method, data }),
      { data: { message: 'Mocked in Codex' } } as AxiosResponse<T>,
    );
    const result = response.data; //(extract returned data)
    console.log(`apiRequest is returning ${JSON.stringify(result)}`); //(log return)
    return result; //(provide response data)
  } catch (err) {
    console.error('apiRequest error:', err); //(log error)
    throw formatAxiosError(err); //(rethrow formatted)
  }
}

type UnauthorizedBehavior = "returnNull" | "throw"; //(configure 401 handling)
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    console.log(`getQueryFn inner is running with ${queryKey[0]}`); //(log start)
    try {
      const res = await codexRequest( //(handle Codex mode)
        () => axiosClient.get<T>(queryKey[0] as string),
        { status: 200, data: null } as AxiosResponse<T>,
      );
      if (unauthorizedBehavior === 'returnNull' && res.status === 401) {
        console.log(`getQueryFn inner is returning null`); //(log 401 handling)
        return null as any;
      }
      const result = res.data; //(extract JSON)
      console.log(`getQueryFn inner is returning ${JSON.stringify(result)}`); //(log return)
      return result;
    } catch (err) {
      if (
        unauthorizedBehavior === 'returnNull' && //(check desired behaviour)
        axios.isAxiosError(err) && //(ensure axios error)
        err.response?.status === 401 //(verify unauthorized status)
      ) {
        console.log(`getQueryFn inner is returning null`); //(log fallback)
        return null as any; //(return null instead of throwing)
      }
      console.error('getQueryFn error:', err); //(log error)
      throw formatAxiosError(err); //(normalize then throw)
    }
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});